极客时间学习笔记之字符串匹配

# BF算法
BF是Brute Force的缩写，中文名叫暴力匹配算法，也叫朴素匹配算法。比如我们要在字符串A中查找字符串B，那字符串A就是主串，字符串B就是模式串，A的长度为n，B的长度为m， BF的思想就是，我们在主串儿中，检查起始位置为0，1，...，n-m，字符长度为m的n-m+1个子串看看有没有跟模式串匹配的。BF算法的时间复杂度是O(n*m)。

# RK算法
RK是Rabin-Karp的缩写，是引入哈希算法，时间复杂度立马会降低。算法思路是对n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小，如果相等，那就说明子串和模式串匹配。因为哈希值是一个数字，数字之间比较相等是非常快速的。

# BM算法
BM是Boyer-Moore的缩写，我们把模式串和主串的匹配过程，看作是模式串在主串中不停地往后滑动的过程；BF和RK算法是模式串每次往后滑动一位，然后模式串重现与主串做匹配；BM算法的改进是找到一种规律让模式串可以在主串中一次性滑动好几位，以此来提高效率；
BM算法引入了坏字符规则和好后缀规则。前面BF和RK算法，模式串在做匹配的时候是从前往后进行匹配，BM算法则是从后往前进行匹配；当发现某个字符无法匹配的时候，就把这个没有匹配的字符叫做坏字符；坏字符对应模式串中的索引是si，坏字符在模式串的下标xi，如果不存在则是-1，遇见坏字符的时候，将模式串向后移动si-xi；这个相减有可能得到负数，所以又引入好后缀规则；
假设遇见了坏字符，对应模式串中的索引为j，好后缀的长度是k，在这里引入suffix数组，数组下标是后缀子串的长度，对应的值是在模式串中跟后缀子串匹配的起始值下标；如果起始下标为0，那就表示这个后缀子串是模式串的前缀子串；
好后缀原则是，我们先在suffix数组中查找好后缀是否存在，如果存在，那么就把模式串向后移动j+1-suffix[k]位；如果好后缀在suffix数组中不存在，如果后缀子串中存在可匹配的前缀子串，那么就将模式串后移r位；r是后缀子串首字母的索引。如果这两个都不满足就直接将模式子串后移m位；

# KMP算法
KMP算法跟BM算法的区别是利用好前缀，他的核心思想是，遇见坏字符串的时候，对于已经匹配的好前缀，找到一种规则，使得模式串可以多向后移动几位；
当遇见坏字符的时候，索引为j，对于好前缀，在他的后缀子串中，寻找最长的可匹配的好前缀的前缀子串，记为{v},长度是k；我们把模式串一次性移动j-k；j更新为j-k，然后继续比较；然后就是如何求前缀子串了；用next数组来辅助，数组的下标是每个前缀结尾字符的下标，值是最长可匹配前缀子串的结尾字符的下标；k-1为0到i-1区间最长可匹配前缀子串的长度，如果B[k]==B[i],那么0到i区间最长可匹配的前缀子串的长度为k；如果B[k]==B[i]不成立，那么就去找0到i-1区间的次长可匹配前缀子串，假设长度是y-1，如果B[y]==B[i]，那么0到i区间的最长可匹配前缀子串长度就是y；
网友留言：
k = next[k]
因为前一个的最长串的下一个字符不与最后一个相等，需要找前一个的次长串，问题就变成了求0到next(k)的最长串，如果下个字符与最后一个不等，继续求次长串，也就是下一个next(k)，直到找到，或者完全没有
