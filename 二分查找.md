极客时间学习笔记之二分查找

# 二分查找
二分查找是针对一个有序的集合，查找的思想有点儿类似分治思想，每次都通过跟区间中间的元素对比，将待查找的区间缩小为一般，直到找到要找的元素，或者待查找区间变为0；二分查找的时间复杂度是O(logn).
我们假设要查找的数组大小为n，在最坏的情况下，是经历k次查找，待查找区间变为0.那k为多少呢，每次查找待查找区间都折半，k=logn。这是一种及其高效的时间复杂度。如果n为2的32次方，我们也只最多查找32次。

#二分查找可以用递归实现，也可以用非递归实现。下面代码是非递归实现，

public int bsearch(int[] a, int n, int value) {
int low = 0;
int high = n - 1;

while (low <= high) {
int mid = (low + high) / 2;
if (a[mid] == value) {
return mid;
} else if (a[mid] < value) {
low = mid + 1;
} else {
high = mid - 1;
}
}

return -1;
}


# 局限性
1.二分查找只适用于数组，因为要随机访问。如果使用链表存储的话，链表不支持随机访问，最坏的情况链表需要遍历n，n/2，n/4，...1,等比数列的和为n-1，跟顺序查找时间复杂度差不多，但是二分查找的时候需要进行多余的计算，所以用链表应该比顺序查找慢。
2.二分查找针对的是有序数据。
3.数据量太小的话，二分查找和顺序查找速度都差不多，只有数据量大的时候，二分查找才有优势。还有就是数组中存储的是字符串的时候，因为字符串的比较比较耗时，为了尽量减少比较次数，二分查找会比较有优势；
4.数据量太大也不适合用二分查找，因为二分查找需要将数据都加载到内存，且需要数组存储，如果是1G的数据，那就需要1G的连续存储空间。
5.二分查找更合适近似的查找问题，比如第一个等于该值的元素，或者最后一个等于该值的元素，最后一个小于该值的元素等等

# 思考题
循环数组中如何查找某个值，以中间点划分，如果首点大于中间点，那么后面是有序数组，前面是循环数组；如果首点小于中间点，那么前面是有序数组，后面是循环数组；如果目标在有序数组则使用二分查找，否则继续上述步骤；


